# A comparative analysis of programming languages for blockchain development with focus on gas efficiency

## Cover page

TODO: in English or Ukrainian?

## Abstract

TODO:
Document size A pages, B illustrations, C references.

TODO: add keywords and sort alphabetically
WEB-3, BLOCKCHAIN, GAS OPTIMISATION, GAS EFFICIENCY, PROGRAMMING LANGUAGE, OPCODE, BYTECODE, COMPILATION, SMART CONTRACT, SOLIDITY

The process of developing smart contracts with different programming languages, further source code compilation into bytecode, and its on-chain execution is an object of research in this paper. The subject of the research is the comparison of different programming languages for smart contract development with focus on gas efficiency of the resulting bytecode.

The main goal is to compare different programming languages for blockchain development, highlighting the gas efficiency of the resulting bytecode, alongside with other language features.

The research is based on the analysis of the Ethereum Virtual Machine (EVM), its code execution, programming languages for smart contract development, the features of corresponding compilers, and the gas efficiency of the resulting bytecode.

TODO: if have time, add more practical application:

> try to evaluate procedure of rewriting SC to a more gas-efficient language
> OR
> rewrite an existing smart contract with more gas-efficient programming language

The results of this research paper describe features of different programming languages for blockchain development, their advantages and disadvantages, and a comparision of gas efficiency of the resulting bytecode.

The research findings can be used by developers to choose the most gas-efficient programming language for blockchain development both prior to the development or for optimisation purposes.

## Table of contents

TODO: update TOC accordingly to what's written below

- Introduction
- Chapter 1. Smart contract development
  - 1.1. Blockchain technology
  - 1.2. Accounts and Smart contracts
  - 1.3. Ethereum Virtual Machine
  - 1.4. Gas
- Chapter 2. Compilation and EVM bytecode
  - 2.1. Compilation process
  - 2.2. EVM bytecode
- Chapter 3. Blockchain programming languages comparison
  - 3.1. List of programming languages for blockchain development
    - 3.1.1. Solidity
    - 3.1.2. Yul
    - 3.1.3. TODO: add more languages
  - 3.2. Criterias for comparison
  - 3.3. Gas comparison
    - 3.3.1. Defining the Smart Contract for comparison
    - 3.3.2. Developing the Smart Contract
    - 3.3.3. Compiling the Smart Contract
    - 3.3.4. Benchmarking the resulting bytecode
- Conclusion
- References

## Introduction

Current state of the research topic. The blockchain technology has gained significant popularity in recent years due to its decentralised nature, security, and transparency. One of the key components of blockchain technology is smart contracts, self-executing contracts with the terms of the agreement between buyer and seller being directly written into lines of code. Smart contracts are executed on the blockchain and can be used for various purposes, such as financial transactions, supply chain management, and digital identity verification.

Smart contracts are executed inside Ethereum Virtual Machine (EVM), a virtual machine that runs on every blockchain node when validating transactions. To prevent spam and unreasonably-heavy computational transactions, a concept of gas was introduced. Each operation in the EVM has a gas cost associated with it, which corresponds to the computational resources required to execute the operation. The gas cost is paid by the transaction sender in Ether, the native cryptocurrency of the Ethereum blockchain.

On the one hand, gas fees allow for a fair and efficient execution of smart contracts, preventing spam and denial-of-service attacks. On the other hand, gas fees can be a significant cost for both the smart contract developers and their users, especially when the contract contains complex and computationally-intensive logic. Consequently, it is crucial to optimise the gas efficiency of the smart contracts to reduce the gas fees and ease the burden of developing and using smart contracts.

Relevance of the research.
Each EVM operation is denoted by an opcode, which constitutes the bytecode of the smart contract. The bytecode is generated by compiling the source code of the smart contract written in a programming language supported by the EVM. The gas cost of the bytecode execution is the sum of the gas costs of the individual opcodes that are executed.

Alongside with the rise of the blockchain technology, different languages for smart contract development have emerged. However, if the same smart contract is developed in different languages, the resulting bytecode may have different gas costs due to the language features and compiler optimisations. Therefore, it is essential to compare different programming languages for blockchain development with focus on gas efficiency of the resulting bytecode.

Purpose and objectives of the research. The purpose of the research "A comparative analysis of programming languages for blockchain development with focus on gas efficiency" is to compare different programming languages for blockchain development, highlighting the gas efficiency of the resulting bytecode, alongside with other language features.

To achieve this goal, the following objectives were outlined:

1. Conduct a research on the blockchain technology
2. Describe how smart contracts and Ethereum Virtual Machine work
3. Define gas and its role in the EVM
4. Investigate the compilation process and resulting bytecode
5. Compile a list of programming languages for blockchain development
6. Define criterias for comparison of programming languages
7. Define and develop a smart contract for comparison
8. Compile and benchmark the resulting bytecode

Object, methods and means of research
An object of the research is the process of developing smart contracts with different programming languages, further source code compilation into bytecode, and its on-chain execution.

During the research, the most popular programming languages for blockchain development were analysed, and the criterias for comparison were defined. A smart contract was developed in different programming languages, compiled into bytecode, and benchmarked for gas consumption.
The result of the research is a comparison of the programming languages with focus on gas efficiency of the resulting bytecode.

Microsoft Visual Studio Code was used as an integrated development environment (IDE) for the development of the smart contract.

Possible areas of application
This paper describes the process of smart contract execution on the EVM-compatible blockchains, the concepts of gas, opcodes, bytecode, and the compilation process. The results of this research can be used by developers to better understand the relation between the bytecode and gas efficiency, and to choose the most gas-efficient programming language for blockchain development.

## Chapter 1. Blockchain and gas fees

The advent of blockchain technology has revolutionized the way transactions and digital interactions are conducted, introducing a decentralized and immutable ledger system that operates independently of traditional financial institutions.Central to this innovation is the concept of "gas fees," a critical component that governs the execution of operations on blockchain networks, particularly in platforms like Ethereum.Understanding gas fees is not only essential for developers working on blockchain-based applications but also for those involved in optimizing the efficiency of these platforms, particularly when it comes to the design and implementation of smart contracts.

At its core, gas fees serve as the economic incentive that drives the processing power required for transactions and smart contract execution on a blockchain.They function as a mechanism to compensate miners or validators for the computational resources they expend.In essence, gas fees ensure that the network remains secure, incentivizing participants to verify and add new transactions to the blockchain while preventing abuse of network resources by imposing a cost on each operation. This concept is crucial in blockchain environments, where decentralized consensus is achieved without a central authority.

The calculation of gas fees is intrinsically tied to the complexity of operations performed on the blockchain. For each operation within a transaction or a smart contract, a specific amount of gas is required. The total gas required is then multiplied by the gas price, which can fluctuate based on network demand.Therefore, the total transaction cost is a function of both the gas used and the prevailing gas price at the time of the transaction. This variability introduces an additional layer of complexity for developers and users alike, as they must anticipate potential costs associated with their operations.

Gas fees also play a pivotal role in the design and development of blockchain-based applications. For developers, the challenge lies in optimizing their smart contracts to be as gas-efficient as possible, minimizing the costs for end-users while ensuring the functionality and security of their applications.The programming language chosen for smart contract development has a significant impact on gas efficiency, as different languages offer varying levels of control over low-level operations and optimizations. This aspect becomes particularly critical in high-traffic environments where gas costs can escalate rapidly, affecting the viability of certain applications or even leading to network congestion.

Moreover, the concept of gas fees extends beyond merely covering computational costs; it also serves as a mechanism for network governance. By adjusting gas limits and fees, blockchain networks can regulate the throughput and scalability of the system. Higher gas fees during periods of congestion can deter excessive or unnecessary transactions, thereby maintaining the network's overall stability.Conversely, lowering gas fees can encourage more activity and experimentation on the network, fostering innovation and adoption.

### 1.1. Blockchain technology

Blockchain technology represents a transformative innovation in digital record-keeping, characterized by its decentralized, transparent, and immutable nature. Unlike traditional centralized systems where a single entity controls data, blockchain operates on a distributed ledger maintained across a network of nodes. This decentralization ensures that no single participant can alter the history of transactions, thereby providing a secure and tamper-resistant platform for various applications. The blockchain's structure, comprising blocks of data linked together in a chronological sequence, underpins its robustness against fraud and data manipulation. Each block contains a list of transactions and is cryptographically secured, making it virtually impossible to alter without the consensus of the network. This inherent security, combined with the transparency of public ledgers, has made blockchain a foundational technology in industries ranging from finance to supply chain management, and most notably, in the development of smart contracts and decentralized applications (DApps).

#### 1.1.1. General overview

Blockchain technology, at its core, is a decentralized ledger system that records transactions across a distributed network of computers, known as nodes. This ledger is composed of a series of blocks, each containing a list of transactions, a timestamp, and a cryptographic link to the previous block. The decentralized nature of blockchain ensures that no single entity has control over the entire network, which enhances security, transparency, and resistance to tampering.

Ethereum, one of the most prominent blockchain platforms, extends the basic principles of blockchain beyond simple transaction processing, enabling the execution of smart contracts—self-executing code with the terms of the agreement directly written into lines of code. These contracts run on the Ethereum Virtual Machine (EVM), a decentralized computation engine that interprets and executes the code across the network's nodes. The Ethereum Yellow Paper, authored by Dr. Gavin Wood, provides the formal specification of the Ethereum protocol, detailing the structure, operation, and implementation of the EVM.

A significant feature of Ethereum is its Turing-complete programming language, which allows developers to create complex logic and execute sophisticated decentralized applications (DApps). This capability distinguishes Ethereum from earlier blockchain implementations, which were typically limited to simple transaction processing and scripting.

In Ethereum, each transaction and smart contract execution requires computational resources, which are quantified in terms of "gas." Gas serves as the unit of measure for the computational work required to execute operations on the EVM. The gas fee is calculated based on the amount of gas consumed by the operation and the gas price set by the user, which can vary depending on network congestion. This mechanism not only compensates miners or validators for their work but also serves as a deterrent against inefficient or malicious use of the network.

Ethereum's blockchain is maintained through a consensus mechanism, historically based on Proof of Work (PoW) and recently transitioned to Proof of Stake (PoS) with Ethereum 2.0. This upgrade significantly improves the network's scalability and energy efficiency, further solidifying Ethereum's position as a leading platform for decentralized applications and blockchain-based innovation. The technical rigor of Ethereum, as detailed in the Yellow Paper, underscores its foundational role in advancing blockchain technology and its practical applications across various industries.

#### 1.1.2. Global state

The concept of the "Global State" in Ethereum is one of the most fundamental and defining features of the platform, meticulously detailed in the Ethereum Yellow Paper. The Global State refers to the entirety of the Ethereum blockchain's current status at any given point in time. It encapsulates all account balances, contract code, and storage, essentially representing the collective "memory" of the network.

In Ethereum, the Global State is maintained across all nodes in the network, and it evolves over time as transactions are executed. Each transaction results in a state transition, whereby the Global State is modified according to the rules defined by the Ethereum protocol. The state transition function, formally denoted as 𝛾 in the Yellow Paper, is the mechanism that dictates how the state changes in response to a given transaction. This function is deterministic, meaning that given the same initial state and transaction, the resulting state will always be identical, ensuring consistency across the distributed network.

Ethereum's state is composed of multiple components, with each account on the network having its own associated state. There are two types of accounts: externally owned accounts (EOAs) and contract accounts. EOAs are controlled by private keys and are primarily used for sending and receiving Ether. Contract accounts, on the other hand, are controlled by code and can execute predefined actions based on the logic written in their smart contracts. Each account in the Ethereum Global State is identified by a unique address and maintains four critical pieces of information: the nonce, the account’s Ether balance, the contract code (if it’s a contract account), and the storage (a mapping of key-value pairs).

The Global State is stored in a data structure called a Merkle Patricia Trie, which is a type of modified Merkle tree designed to optimize the retrieval and verification of information. The use of this data structure ensures that any part of the state can be quickly and efficiently retrieved and verified, which is critical for maintaining the integrity and performance of the network. The root of this trie, known as the state root, is stored in the block header, and it provides a cryptographic summary of the entire state at the time the block was mined. This root allows any node in the network to verify the state independently without needing to store the entire blockchain, thus contributing to the decentralized nature of Ethereum.

In addition to storing balances and contract data, the Global State also encompasses the entire storage of all smart contracts on the Ethereum blockchain. Each contract has its own storage, which is organized as another Merkle Patricia Trie, allowing for efficient and secure storage of arbitrary data. This hierarchical structure of tries within tries is one of the reasons Ethereum is capable of scaling its state management to accommodate a vast and growing number of smart contracts and decentralized applications (DApps).

When a transaction is executed, it can potentially alter the Global State by modifying account balances, invoking smart contracts, or altering the storage associated with a contract account. The execution of a transaction involves the Ethereum Virtual Machine (EVM), which processes the transaction and computes the resulting state transition. The EVM operates on a stack-based architecture and uses gas to measure the computational effort required to execute operations, ensuring that resources are used efficiently and preventing the network from being overwhelmed by costly computations.

The integrity and security of the Global State are upheld through Ethereum’s consensus mechanism. Historically based on Proof of Work (PoW) and now transitioning to Proof of Stake (PoS) with Ethereum 2.0, the consensus mechanism ensures that all nodes agree on the current state of the blockchain. Each new block appended to the blockchain includes a new state root, representing the Global State after all transactions in the block have been processed. Validators or miners, depending on the consensus mechanism, are responsible for validating and proposing these new blocks, thereby ensuring the continuity and immutability of the Ethereum Global State.

#### 1.2.3. Transaction and execution

In Ethereum, transactions are the primary means by which state transitions occur within the blockchain. A transaction, as defined in Section 4.2 of the Ethereum Yellow Paper, is a signed data package that stores a message to be sent from an externally owned account (EOA) to another account on the network. Transactions are the mechanism through which value is transferred and smart contracts are executed, driving the functionality of decentralized applications (DApps) and the broader Ethereum ecosystem.

##### 1.2.3.1 Transaction Structure

A transaction in Ethereum contains the following fields, each of which plays a crucial role in the transaction's execution:

- Nonce: This is a counter that indicates the number of transactions sent from a particular account. It serves as a unique identifier for each transaction from the same account, preventing double-spending and ensuring that transactions are executed in the correct order.
- Gas Price: The gas price specifies the amount of Ether that the sender is willing to pay per unit of gas for the transaction to be processed. This value is set by the sender and can fluctuate depending on network demand. Higher gas prices incentivize miners or validators to prioritize the transaction.
- Gas Limit: The gas limit defines the maximum amount of gas the sender is willing to expend on the transaction. This value caps the total computational resources that can be used, protecting the sender from incurring excessively high costs if the transaction fails or requires more resources than expected.
- To: This field contains the address of the recipient account. If the transaction is intended to deploy a new contract, the "To" field is left empty.
- Value: The value field specifies the amount of Ether to be transferred from the sender’s account to the recipient’s account. If the transaction is calling a smart contract, this value might be used within the contract's logic.
- Data: The data field is optional and can contain arbitrary data, typically used for invoking specific functions within a smart contract. This field may also include the contract's initialization code when deploying a new contract.
- v, r, s: These fields represent the components of the transaction’s digital signature, ensuring that the transaction is authenticated and has not been tampered with. The v, r, and s values are derived from the sender's private key using the Elliptic Curve Digital Signature Algorithm (ECDSA).

Together, these fields define the parameters and constraints of a transaction, ensuring that it can be validated and executed in a manner consistent with the Ethereum protocol.

##### 1.2.3.2 Transaction Receipt

After a transaction is executed, a transaction receipt is generated, which provides a summary of the transaction’s execution. As detailed in Section 4.4.1 of the Ethereum Yellow Paper, a transaction receipt includes the following fields:

- Post-Transaction State Root: This is the root of the global state trie after the transaction has been executed. It serves as a cryptographic proof of the new state, allowing anyone to verify the state of the blockchain post-transaction.
- Cumulative Gas Used: This field records the total amount of gas used in the block up to and including the transaction in question. It provides an insight into the gas consumption of the entire block.
- Bloom Filter: The bloom filter is a compact data structure that encodes information about the logs generated during the transaction execution. It is used for efficient searching and filtering of logs by decentralized applications and users.
- Logs: Logs are data records generated during the execution of a transaction, often as a result of events emitted by smart contracts. These logs are not stored on the blockchain but are included in the transaction receipt, allowing for easy retrieval and verification by external applications.

The transaction receipt thus encapsulates key information about the execution of the transaction, providing both a historical record and a tool for developers and users to analyze and interact with past transactions.

##### 1.2.3.3 Transaction Execution Process

The execution of a transaction in Ethereum is a multi-step process that ensures the integrity and consistency of the network, as outlined in Chapter 6 of the Ethereum Yellow Paper. The process can be broken down into three main stages: transaction validation, logic execution, and receipt creation.

1. Transaction Validation: Before a transaction can be executed, it must first be validated by the network. This involves several checks, including:

- Nonce Check: The nonce must match the expected value for the sender's account. If it does not, the transaction is considered invalid.
- Signature Verification: The v, r, and s values are used to verify the sender’s signature, ensuring that the transaction has been authorized by the account holder.
- Gas Check: The transaction must have a gas limit that is sufficient to cover the intrinsic cost of the transaction. This intrinsic cost includes a base fee plus additional costs for the size of the transaction data and any specific operations it may invoke.

2. Logic Execution: Once validated, the transaction is executed by the Ethereum Virtual Machine (EVM). This execution involves the following steps:

- Gas Consumption: As the transaction is processed, gas is consumed based on the computational complexity of the operations. If the transaction runs out of gas before completion, it is reverted, but the gas spent is not refunded.
- State Modification: The EVM processes the transaction, potentially modifying the global state. This could involve updating account balances, invoking smart contracts, or altering contract storage.
- Log Emission: If the transaction includes events or triggers within a smart contract, logs are emitted and recorded in the transaction receipt.

3. Receipt Creation: After the transaction is executed, a transaction receipt is generated. This receipt includes the post-transaction state root, cumulative gas used, bloom filter, and logs, as described earlier. The receipt is then stored on the blockchain, providing a permanent record of the transaction's outcome.

The entire transaction execution process is governed by the Ethereum consensus mechanism, ensuring that all nodes in the network reach agreement on the validity and results of each transaction. This robust and meticulous process, as detailed in the Yellow Paper, is foundational to Ethereum’s security, consistency, and trustworthiness as a decentralized platform.

#### 1.2.4. Gas fees

Gas fees are a fundamental component of the Ethereum network, serving as the mechanism by which computational resources are measured and compensated. In Ethereum, every operation performed by the Ethereum Virtual Machine (EVM), whether it's executing a smart contract, sending a transaction, or performing data storage, requires a certain amount of computational work. Gas is the unit of measurement used to quantify this work, and gas fees are the cost that users must pay to execute these operations on the network.

##### 1.2.4.1. Components of Gas Fees

The gas fee for a transaction is determined by several factors, as detailed in Section 5 of the Ethereum Yellow Paper:

1. Gas Cost: Each operation in the EVM, from simple arithmetic to complex contract executions, has an associated gas cost. The gas cost is a fixed value assigned to each operation, reflecting the computational effort required. For example, simple operations like adding two numbers might cost only a few units of gas, while more complex operations like storing data in contract storage might cost significantly more.

2. Gas Limit: The gas limit is set by the sender of the transaction and represents the maximum amount of gas they are willing to spend. The gas limit must be high enough to cover the intrinsic gas cost of the transaction, which includes a base fee for the transaction itself, as well as additional fees for the data payload and specific operations. If the gas limit is set too low, the transaction will fail, but the gas used up to that point will still be consumed.

3. Gas Price: The gas price is the amount of Ether the sender is willing to pay per unit of gas. This value is set by the sender and is typically measured in gwei (1 gwei = 10^-9 Ether). The gas price can fluctuate based on network demand, with higher prices offering an incentive for miners or validators to prioritize the transaction. The total gas fee paid by the sender is the product of the gas used and the gas price.

##### 1.2.4.2. Gas Fees Calculation

The total gas fee for a transaction is calculated as follows:

```txt
Total Gas Fee = Gas Used × Gas Price
```

Where:

- Gas Used: This is the actual amount of gas consumed by the transaction during execution. If the transaction completes successfully, the gas used will be equal to or less than the gas limit set by the sender. If the transaction runs out of gas before completion, it is reverted, but the gas up to that point is still deducted from the sender’s account.

- Gas Price: This is the price per unit of gas, as determined by the sender.

For instance, if a transaction consumes 21,000 units of gas (a typical value for a simple Ether transfer) and the sender sets a gas price of 20 gwei, the total gas fee would be:

```txt
21,000 × 20 gwei = 420,000 gwei = 0.00042 Ether
```

##### 1.2.4.3. Intrinsic Gas Cost

The intrinsic gas cost is the base cost for executing a transaction, and it is composed of several elements:

1. Base Transaction Cost: This is a fixed cost for any transaction, which covers the basic overhead of processing the transaction on the blockchain. As per the Yellow Paper, the base cost for a standard transaction is 21,000 gas.

2. Data and Storage Costs: Transactions that include data (such as contract execution or deploying a contract) incur additional gas costs. The cost is proportional to the amount of data sent or stored, with operations that write to storage being particularly expensive, as they contribute to the growth of the blockchain state.

3. Operation-Specific Costs: Certain operations within a transaction, such as creating a new contract or invoking specific EVM opcodes, have additional gas costs associated with them. These costs are predefined in the Ethereum protocol to reflect the relative computational intensity of each operation.

##### 1.2.4.4. Gas Refunds and Efficiency

Ethereum also provides mechanisms for optimizing gas usage and potentially receiving gas refunds. For example, if a transaction deletes a contract or clears storage, gas can be refunded to the sender, reducing the overall cost of the transaction. This incentivizes developers to write more efficient smart contracts, as unnecessary data and operations can significantly increase gas costs.

##### 1.2.4.5. Economic and Network Implications

Gas fees play a critical role in the economics of the Ethereum network. They incentivize miners or validators to include transactions in the blockchain and help prevent network abuse by imposing a cost on every operation. High gas fees during periods of network congestion can serve as a natural deterrent to excessive or unnecessary transactions, while also reflecting the scarcity of computational resources on the network.

In conclusion, gas fees are a sophisticated mechanism that balances the computational needs of the Ethereum network with the economic realities of decentralized transaction processing. They ensure that all participants in the network contribute to the cost of maintaining and securing the blockchain, while also encouraging the efficient use of resources through careful management of gas limits, prices, and intrinsic costs. The Ethereum Yellow Paper’s detailed specification of gas costs and fees underscores the importance of these mechanisms in maintaining the network’s integrity, scalability, and long-term sustainability.

#### 1.1.5. Blocks

In Ethereum, the blockchain is composed of a series of blocks, each containing a collection of transactions and serving as a snapshot of the network’s state at a specific point in time. The structure of an Ethereum block, as detailed in Section 4.3 of the Ethereum Yellow Paper, is fundamental to the operation of the network, ensuring that transactions are recorded in a secure, immutable, and orderly manner.

An Ethereum block is composed of two primary parts: the block header and the block body.

1. Block Header: The block header contains critical metadata about the block, which includes:

   - Parent Hash: This field contains the hash of the previous block's header, linking the current block to its predecessor and forming the continuous chain of blocks that constitutes the blockchain. This linkage ensures that any alteration to a previous block would invalidate the subsequent blocks, thereby securing the integrity of the blockchain.
   - Uncle Hash: Ethereum allows for the inclusion of "uncle" blocks—blocks that were mined concurrently but did not become part of the main chain. The uncle hash is a hash of the list of uncle blocks included in the current block, which helps improve chain security and rewards miners for their work.
   - State Root: The state root is the root hash of the Merkle Patricia Trie that represents the global state of Ethereum after all transactions in the block have been executed. This root serves as a cryptographic proof of the network’s state at the time the block was mined.
   - Transactions Root: This is the root hash of the Merkle Trie containing all transactions included in the block. The transactions root allows for efficient verification and retrieval of transactions.
   - Receipts Root: Similar to the transactions root, the receipts root is the root hash of the Merkle Trie containing all transaction receipts. It enables efficient access to the results and logs generated by the transactions.
   - Logs Bloom: This is a bloom filter that summarizes all the logs generated by transactions in the block, allowing for efficient searching and filtering of specific events.
   - Difficulty: The difficulty value adjusts the complexity of the Proof of Work (PoW) algorithm, ensuring that blocks are mined at a consistent rate, despite variations in the network's computational power.
   - Number: This is the block number, which indicates the position of the block within the blockchain. The genesis block, being the first block, has a block number of zero.
   - Gas Limit and Gas Used: The gas limit sets the maximum amount of gas that can be consumed by transactions in the block, while gas used reflects the total gas consumed by all transactions within the block.
   - Timestamp: This field records the time at which the block was mined, providing a chronological order to the blockchain.
   - Extra Data: An optional field that can contain up to 32 bytes of arbitrary data, often used for custom purposes by miners.
   - Mix Hash and Nonce: These fields are used in the Proof of Work (PoW) algorithm, with the mix hash representing the proof-of-work solution, and the nonce being the value that miners adjust to find a valid hash.

2. Block Body: The block body contains two main elements:
   - Transaction List: This is the list of all transactions included in the block. Each transaction in this list contributes to the state transition from the state of the previous block to the new state.
   - Uncles: The block body also includes a list of uncle blocks, which are valid blocks that were mined almost simultaneously with the parent block but did not become part of the main chain. Including uncles helps to improve network security by rewarding miners who contribute to the network, even if their blocks do not become part of the main chain.

Blocks in Ethereum are cryptographically linked together to form the blockchain. This linkage is achieved through the parent hash field in each block header, which points to the hash of the previous block. This creates a continuous chain from the current block back to the genesis block. The use of cryptographic hashes ensures that any modification to the data in a previous block would result in a different hash, breaking the chain and alerting the network to the tampering.

The process of adding new blocks to the blockchain is governed by Ethereum's consensus mechanism, historically Proof of Work (PoW) and now transitioning to Proof of Stake (PoS) with Ethereum 2.0. In PoW, miners compete to solve complex mathematical puzzles, and the first to find a solution can propose a new block. In PoS, validators are chosen to propose new blocks based on the amount of Ether they have staked. Regardless of the consensus mechanism, once a block is added to the blockchain, it becomes a permanent part of the ledger, contributing to the immutability and security of the Ethereum network.

This structured and linked block design ensures that Ethereum maintains a consistent and secure record of all transactions and state changes, enabling the decentralized operation of smart contracts and applications across the network.

#### 1.1.6. Consensus algorithms and block finalization

Consensus algorithms are the mechanisms that allow distributed networks like Ethereum to agree on the state of the blockchain, ensuring that all participants maintain a consistent and secure ledger without a central authority. In Ethereum, two primary consensus algorithms have been employed: Proof of Work (PoW) and Proof of Stake (PoS), each with its own method of securing the network and achieving consensus.

##### 1.1.6.1 Proof of Work (PoW)

Historically, Ethereum utilized Proof of Work (PoW), the same consensus mechanism used by Bitcoin. In PoW, miners compete to solve complex cryptographic puzzles, where the first to find a valid solution is granted the right to propose a new block. The difficulty of these puzzles adjusts dynamically to maintain a consistent block time, typically around 15 seconds in Ethereum. PoW's security comes from the immense computational effort required to solve these puzzles, making it prohibitively expensive for any single entity to take control of the network. However, PoW is also energy-intensive and has scalability limitations, which prompted the transition to Proof of Stake.

##### 1.1.6.2. Proof of Stake (PoS)

Proof of Stake (PoS) is the consensus algorithm introduced with Ethereum 2.0, designed to address the limitations of PoW. In PoS, validators are chosen to propose and attest to new blocks based on the amount of Ether they have staked as collateral. This staking process replaces the need for energy-intensive computations, significantly reducing the environmental impact of securing the network. Validators are incentivized to act honestly by the potential loss of their staked Ether if they attempt to undermine the network. PoS also enables more efficient scalability and faster finalization times, making it a more sustainable solution for Ethereum’s long-term growth.

##### 1.1.6.3. Block Finalization

Block finalization refers to the point at which a block is considered permanently included in the blockchain, meaning that it cannot be altered or removed without the consensus of the entire network. In PoW, finalization is probabilistic; the more blocks that are added on top of a given block, the more secure it becomes, reducing the likelihood of a reorganization (or "reorg") that would remove it. Traditionally, a block is considered final after six subsequent blocks, often referred to as the "6 confirmations" rule.

In PoS, finalization is more deterministic and is achieved through a process known as checkpointing. Validators periodically vote on the state of the blockchain at certain intervals (epochs). When two-thirds of the validators agree on a checkpoint, all preceding blocks up to that checkpoint are considered finalized. This mechanism not only enhances security by preventing reorgs but also speeds up the finalization process, providing faster guarantees that transactions included in these blocks are immutable.

The transition from PoW to PoS in Ethereum represents a significant evolution in blockchain consensus, offering improvements in energy efficiency, scalability, and finality. This duality of consensus mechanisms highlights Ethereum’s commitment to innovation and its adaptability to the growing demands of decentralized applications and global adoption.

#### 1.1.7. EIPs and ERCs

Ethereum Improvement Proposals (EIPs) and Ethereum Request for Comments (ERCs) are essential mechanisms for proposing, discussing, and implementing changes to the Ethereum protocol and its ecosystem. EIPs serve as formal documents that outline new features, enhancements, or processes for the Ethereum network, covering a broad range of topics from core protocol changes to application standards and network upgrades.

EIPs are categorized based on their scope and impact. Core EIPs, for example, propose changes that directly affect the consensus layer of Ethereum, such as modifications to the Ethereum Virtual Machine (EVM) or changes to the consensus algorithm. Network upgrades like "The Merge" or "EIP-1559," which introduced a new fee-burning mechanism, are driven by Core EIPs. The process for an EIP involves rigorous discussion, testing, and community feedback before it can be accepted and implemented into the Ethereum mainnet.

ERCs, on the other hand, are a subset of EIPs focused on application-level standards, particularly those related to smart contracts and tokens. The most famous ERC is ERC-20, which defines a standard for fungible tokens and has become the foundation for countless tokens on Ethereum. Similarly, ERC-721 defines the standard for non-fungible tokens (NFTs), enabling the creation of unique digital assets.

Both EIPs and ERCs are community-driven, emphasizing Ethereum's decentralized ethos. They allow developers, users, and stakeholders to collaborate on the network’s evolution, ensuring that Ethereum remains adaptable and innovative. By enabling structured and transparent changes, EIPs and ERCs play a crucial role in shaping the future of Ethereum, fostering a vibrant ecosystem of decentralized applications and services.

#### 1.1.8. Clients

In the Ethereum network, clients, also known as nodes, are software implementations that enable participants to interact with the blockchain. Execution clients are responsible for executing smart contracts, validating transactions, maintaining the network’s state, and ensuring consensus across the distributed network. These clients provide the necessary infrastructure for developers, miners, validators, and users to access and engage with Ethereum.

Several execution clients exist, each with its own unique features and optimizations. The most prominent and widely used Ethereum clients include:

1. **Geth (Go-Ethereum)**: Developed by the Ethereum Foundation, Geth is the most popular and widely used client. Written in Go, it is known for its robust performance and extensive feature set, making it a preferred choice for both developers and operators of Ethereum nodes.

2. **Nethermind**: Written in C#, Nethermind is known for its high performance and compatibility with various platforms, including Windows. It is often chosen by developers looking for a client with strong support for debugging and analysis tools.

3. **Besu**: Developed by the Hyperledger Foundation, Besu is an Ethereum client written in Java. It is particularly popular among enterprises due to its support for both public and private Ethereum networks, as well as its strong focus on permissioned blockchain use cases.

4. **Erigon**: Formerly known as Turbo-Geth, Erigon is a performance-optimized client written in Go. It focuses on reducing resource usage and improving synchronization speed, making it ideal for operators looking for efficiency.

Each of these clients plays a crucial role in maintaining the decentralized and resilient nature of Ethereum. By offering diverse options tailored to different needs, they contribute to the robustness and scalability of the Ethereum network.

### 1.2. Accounts and Smart contracts

In Ethereum, accounts and smart contracts form the backbone of all interactions on the blockchain. Accounts, which can be either externally owned or contract-based, are the primary entities that hold Ether and initiate transactions. Externally owned accounts (EOAs) are controlled by private keys and are typically used by individuals or organizations to send and receive funds. In contrast, contract accounts are governed by code and operate autonomously based on predefined rules.

#### 1.2.1. Accounts

In Ethereum, every interaction on the blockchain is associated with an address, a 160-bit identifier that represents either an Externally Owned Account (EOA) or a Smart Contract (SC). The difference between these two types of accounts is fundamental to how Ethereum operates. An Externally Owned Account (EOA) is controlled by a private key and is typically associated with a user or entity. EOAs are the source of transactions on the Ethereum network, including sending Ether and interacting with smart contracts. A Smart Contract (SC), on the other hand, is a contract account that is controlled by code rather than a private key. Once deployed on the Ethereum blockchain, a smart contract operates autonomously according to its programmed logic, responding to incoming transactions based on its predefined rules.

Each Ethereum address, whether associated with an EOA or an SC, contains several key fields, as described in the Ethereum Yellow Paper:

1. Nonce: This field represents a counter that tracks the number of transactions sent from an EOA or the number of contract creations initiated by an SC. It ensures that transactions are processed in order and prevents replay attacks.

2. Balance: The balance field indicates the amount of Ether held by the account. For EOAs, this balance can be freely transferred, while for SCs, it can be used according to the contract’s logic.

3. Storage Root: This field is unique to smart contracts and represents the root of a Merkle Patricia Trie that encodes the contract’s storage. It is used to efficiently manage and access the data stored within the smart contract.

4. CodeHash: Also specific to smart contracts, the CodeHash field contains the hash of the contract’s code. This hash enables the network to efficiently verify the contract’s code during execution without storing the actual code in the address field.

These fields collectively define the state and capabilities of each Ethereum address, ensuring that all transactions and contract executions are handled securely and efficiently within the network.

#### 1.2.2. Contract creation

Contract creation in Ethereum is a specialized transaction type that results in the deployment of a new smart contract on the blockchain. This process follows a defined sequence, as outlined in Section 7 of the Ethereum Yellow Paper, ensuring that the contract is properly initialized and integrated into the Ethereum network.

While Externally Owned Accounts (EOAs) are the most common initiators of contract creation transactions, it is important to note that smart contracts themselves can also create new contracts. This capability allows for complex, multi-contract systems where contracts deploy or interact with other contracts autonomously, enhancing the flexibility and programmability of the Ethereum platform.

When an EOA or another smart contract initiates a contract creation transaction, the transaction's "To" field is left empty, indicating the intention to create a new contract. The transaction must include a data field containing the contract's initialization code, which is responsible for setting up the contract's initial state.

The sequence of events for contract creation is as follows:

1. Transaction Initiation: The initiating account (EOA or smart contract) sends a transaction with the "To" field empty, the data field containing the contract’s initialization code, and a specified amount of gas. The transaction undergoes validation, ensuring the sender has sufficient funds, the nonce is correct, and in the case of smart contracts, that the execution context is valid.

2. Address Generation: The address for the new contract is generated deterministically based on the sender’s address and the sender's nonce. This ensures that each contract created by the same sender (whether an EOA or a smart contract) has a unique address.

3. Execution of Initialization Code: The Ethereum Virtual Machine (EVM) executes the contract's initialization code. During this process, the EVM may consume gas as it processes the instructions in the code. The output of this code execution, which is typically the runtime bytecode, is stored in the contract’s CodeHash field.

4. Storage Setup: The initialization code may also set up the contract’s initial storage, which is represented by the Storage Root in the contract account. This storage is managed via a Merkle Patricia Trie, allowing for efficient retrieval and updates.

5. Contract Finalization: Once the initialization code has been executed and the contract’s code and storage have been set, the contract is officially created. The contract's address, CodeHash, and initial storage are recorded on the blockchain, and any remaining gas is refunded to the sender.

6. Deployment: The contract is now live on the Ethereum network, and its address can be used to interact with it through subsequent transactions. The contract operates autonomously, executing its code whenever it receives transactions that trigger its functions.

This sequence ensures that smart contracts, whether created by EOAs or other smart contracts, are deployed consistently and securely, maintaining the integrity and reliability of the Ethereum blockchain.

#### 1.2.3. Message call

A message call in Ethereum refers to the process by which an account, whether an Externally Owned Account (EOA) or a smart contract, interacts with another smart contract or sends Ether to another account. Unlike a transaction, which originates from an EOA and creates a new state on the blockchain, a message call is an internal process that may not necessarily create new blocks but can lead to state changes within the Ethereum Virtual Machine (EVM).

The sequence of steps for a message call, as described in Section 8 of the Ethereum Yellow Paper, is as follows:

1. Initiation: A message call is initiated by an account, either an EOA via a transaction or a smart contract as part of its execution. The message includes key parameters such as the recipient address, the amount of Ether to be transferred (if any), the input data, and the gas limit allocated for the call.

2. Recipient Address: The recipient of the message call is specified by an address, which can correspond to either an EOA or another smart contract. If the recipient is a smart contract, the message call may trigger the execution of the contract’s code.

3. Gas Allocation: A portion of the gas provided for the transaction or the parent execution context is allocated to the message call. This gas allocation determines how much computation the recipient contract can perform. If the gas runs out during execution, the message call fails, and all state changes are reverted, except for the gas consumed up to that point.

4. Code Execution: If the recipient is a smart contract, the EVM loads the contract’s code from the blockchain and begins execution. The input data provided in the message call is used as the input for the contract’s functions. The contract can perform various operations, including reading and writing to storage, sending Ether, or making further message calls to other contracts.

5. Return Data: Upon completion of the code execution, the contract returns data, which is then passed back to the calling account or contract. This data could be a simple confirmation of success, a computation result, or an error message if the call failed.

6. Finalization: The message call finalizes by either succeeding or failing. If it succeeds, the state changes made during execution are committed to the blockchain, and any unused gas is refunded. If it fails, all state changes are reverted, except for the gas used.

Message calls are fundamental to the interaction between contracts within the Ethereum network, enabling the execution of complex, decentralized applications that can dynamically interact with each other.

### 1.3. Bytecode

TODO: explain the bytecode structure, how opcodes are extracted etc.

### 1.4. Ethereum Virtual Machine

Ethereum Virtual Machine (EVM) is a crutial component of the Ethereum blockchain, acting as a quasi-Turing-complete virtual machine that executes transactions within the Ethereum ecosystem.
As clarified in Ethereum Yellow Paper, "quasi" stems from the fact that the total amount of computations performed is explicitly bounded by a separate parameter called gas.
The aforementioned Ethereum Yellow Paper also rigoriously defines the behavior of the EVM, which includes the compliance with the rules of the global (persistant) and local (not persistant) state changes alongside with calculation and deduction of the gas costs of the performed operations.

#### 1.4.1. EVM overview

The EVM operates as a simple stack-based architecture with a word size of 256 bits, chosen specifically to support the Keccak256 hash function and elliptic-curve calculations.
The memory model is a straightforward word-addressed byte array, while the stack has a maximum depth of 1024 items.
The machine also includes a separate storage model, which is conceptually similar to memory but differs in that it is a word-addressable word array. Unlike volatile memory, storage is non-volatile and persists as part of the system global state.
Initially, all locations in both storage and memory are well-initialized as zero.

The EVM does not adhere to the traditional von Neumann architecture: instead of storing program code in generally accessible memory or storage, the code is kept in a separate virtual ROM, accessible only through specialized instructions.

The machine can have exceptional execution halting for several reasons, including stack underflow, invalid instructions, and out-of-gas exceptions. The latter is a critical feature of the EVM, as it prevents infinite loops and other computationally intensive operations from consuming all available resources.
During exceptional halting, all performed state changes are reverted and this fact is reported to the execution agent, which deals with it separetely.

#### 1.4.2. Machine state

For the EVM to operate, it must maintain a machine state, which consists of the following components:

- Gas available (g) - the amount of gas remaining for the current transaction. Decreases as operations are executed and is used to pay for computation.
- Program counter (pc) - the number of the current instruction being executed. Increments by one after each instruction. Can be modified by JUMP and JUMPI instructions.
- Memory contents (m) - word-addressable byte array, with each byte array being 32 bytes long. Used for temporary storage during execution.
- Active number of words in memory (i) - the number of words currently used in memory, counting from 0. Increases as memory is accessed and decreases as memory is freed.
- Stack contents (s) - a stack of 256-bit words used for storing intermediate values during execution. Grows and shrinks as values are pushed and popped.
- Returndata buffer (o) - a buffer used to store data returned from a message call. Cleared after each call.

Apart from the machine state, the EVM also inherits execution environment (I), which includes:

- I_a, the address of the account which owns the code that is executing.
- I_o, the sender address of the transaction that originated this execution.
- I_p, the price of gas paid by the signer of the transaction that originated this execution (effective gas price).
- I_d, the byte array that is the input data to this execution (transaction data).
- I_s, the address of the account which caused the code to be executing (transaction sender).
- I_v, the value, in Wei, passed to this account as part of the same procedure as execution (transaction value).
- I_b, the byte array that is the machine code to be executed.
- I_H, the block header of the present block.
- I_e, the depth of the present message-call or contract-creation (i.e. the number of CALLs or CREATE(2)s being executed at present).
- I_w, the permission to make modifications to the state.

#### 1.4.3. Opcodes

In EVM, each operation has its own number, therefore the short name - "opcode" (operation code). The EVM has a total of 143 opcodes, each descibed by:

- Value - the number of the opcode;
- Mnemonic - the short descriptive name of the opcode;
- Items popped - the number of items popped from the stack;
- Items pushed - the number of items pushed to the stack;
- Intrinsic gas cost - the base gas cost of the opcode. The actual gas cost can be higher due to additional factors;
- Operation logic - a description of the operation performed by the opcode.

Detailed information about each opcode can be found in Appendix TODO:.

It is worth noting that some of the opcodes read data from the bytecode itself, rather than the stack. These include the PUSH1...PUSH32 opcodes, which push a constant value to the stack.

All the opcodes are divided into groups based on their functionality. These groups include:

- 0s - Stop and Arithmetic Operations
- 10s - Comparison & Bitwise Logic Operations
- 20s - KECCAK256
- 30s - Environmental Information
- 40s - Block Information
- 50s - Stack, Memory, Storage and Flow Operations
- 5f, 60s and 70s - Push Operations
- 80s - Duplication Operations
- 90s - Exchange Operations
- a0s - Logging Operations
- f0s - System operations

The numeration of the opcodes is not continuous, as some numbers are reserved for future use.

#### 1.4.4. Fees overview

In EVM, gas fees are charged in three specific scenarios, each being a prerequisite for executing an operation. The first and most common scenario involves the intrinsic gas cost associated with the computation required for the operation (opcode) itself.
The second scenario arises when gas is deducted as part of a payment for initiating a subordinate message call or creating a new contract, which applies to operations such as CREATE, CREATE2, CALL, and CALLCODE. Lastly, gas is also consumed when there is an increase in memory usage during execution.

During the execution of a contract, the total fee related to memory usage is based on the smallest multiple of 32 bytes that covers all memory indices accessed (whether for reading or writing).
These memory fees are assessed on a just-in-time basis. For example, accessing a memory area that extends at least 32 bytes beyond any previously accessed region will trigger an additional fee.

Storage fees operate under a slightly different model. To encourage efficient storage usage — since excessive storage increases the state database size for all nodes — the gas cost for an operation that clears a storage entry does not only waived, but also gets a refund.
In fact, this refund is effectively provided up front because the initial cost of using a storage location is significantly higher than that of ongoing usage. This design incentivizes developers to clear unused storage, helping manage the overall blockchain state size.

The gas cost of an operation is calculated as the sum of the intrinsic gas cost, possible gas cost of passing arguments to instruction, as well as memory access, either cold or warm.
Ethereum Yellow Paper divides opcodes into such groups based on their gas cost:

- W_zero = {STOP, RETURN, REVERT}
- W_base = {ADDRESS, ORIGIN, CALLER, CALLVALUE, CALLDATASIZE, CODESIZE, GASPRICE, COINBASE, TIMESTAMP, NUMBER, PREVRANDAO, GASLIMIT, CHAINID, RETURNDATASIZE, POP, PC, MSIZE, GAS, BASEFEE, PUSH0}
- W_verylow = {ADD, SUB, NOT, LT, GT, SLT, SGT, EQ, ISZERO, AND, OR, XOR, BYTE, SHL, SHR, SAR, CALLDATALOAD, MLOAD, MSTORE, MSTORE8, PUSH1, ..., PUSH32, DUP*, SWAP*}
- W_low = {MUL, DIV, SDIV, MOD, SMOD, SIGNEXTEND, SELFBALANCE}
- W_mid = {ADDMOD, MULMOD, JUMP}
- W_high = {JUMPI}
- W_copy = {CALLDATACOPY, CODECOPY, RETURNDATACOPY}
- W_extaccount = {BALANCE, EXTCODESIZE, EXTCODEHASH}
- W_call = {CALL, CALLCODE, DELEGATECALL, STATICCALL}

with the following gas costs:

- G_zero = 0
- G_base = 2
- G_verylow = 3
- G_low = 5
- G_mid = 8
- G_high = 10
- G_copy = G_verylow + 3 \* rounddown(stack[2] / 32)
- G_extaccount = 100, if an account being accessed is "warm", 2600 if "cold"

More detailed information about gas costs for each opcode is presented in Appendix TODO:.

#### 1.4.5. Halting

As previously stated, the EVM can halt execution for various reasons, however two groups can be distinguished: exceptional halting and normal halting.

Ethereum Yellow Paper specifies that the execution is in an exceptional halting state if there is insufficient gas, if the instruction (opcode) is invalid, if there are insufficient stack items for the operation,
if the new stack size after performing an operation is larger than 1024, if a JUMP/JUMPI destination is invalid, or state modification is attempted during a static call.

JUMP/JUMPI destination is valid if it is occupied by the JUMPDEST opcode. Such positions must be on valid instruction boundaries, rather then in the middle of the PUSH operations, and must appear within the explicitly defined portion of the code.

The normal halting state is reached when the VM executes either opcode from the two groups: RETURN, REVERT or STOP, SELFDESTRUCT, or reaches the end of the code. In the latter case, the STOP opcode is executed.

#### 1.4.6. Execution

Execution model is defined recursively as a function X over the full system state, the machine state, accrued system substate and the execution environment.
The results of X are a changed full system state, changed machine state, and the output data, and are determined conditionally:

- if the system is in an exceptional halting state, a full system state is not changed, and output data is empty.
- if a system is in a normal halting state (e.g. the current instruction is REVERT), then a full system state is not changed, an amount of gas consumed by the instruction is deducted from the current machine state, and output data is the result of the current instruction.
- if an output of the current instruction is not empty, then the result is an application of the iterator function O (which defines the result of a single cycle of the state machine).
- otherwise, the result is an application of the execution model function X to the result of the iterator function O.

Iterator function O is defined as a function of the current full system state, machine state, accrued system substate, and execution environment, and outputs of the same meaning. The function is defined as following:

- The execution environment is not changed.
- The full system state and accrued substate are changed according to the effects of the current instruction.
- The changes to the machine state are the following:
  - a specific for a current instruction amount of items are popped from and pushed to the stack
  - gas left is decreased by the gas cost of the current instruction
  - program counter is modified according to the current instruction: either set to the JUMP/JUMPI destination, or incremented so that the next instruction is executed (PUSH1...PUSH32 require bigger increment to account for the data being pushed).

Informally, the execution model function X is cycled (Yellow Paper specifies recursion, but the implementation can use a simple loop), executes instructions one by one, which results in changes to the machine and global state,
until either the system is in an exceptional halting state, which discards all changes made, or the machine has reached a controlled halt, which preserves the changes made and returns the output data.

### 1.5. Fee sources conslusion

TODO: describe main sources of gas fees after reviewing how gas fees are calculated in the EVM.

## Chapter 2. Programming languages and compilation

### 2.1. Programming languages

TODO:

- Declarative / imperative
- static / dynamic typing
- object-oriented / functional / procedural programming
- which language generation / abstraction level
- memory-management tools (garbage collection)
- type checking
- bounds checking
- static / dynamic scope
- explicit access control

### 2.2. Compilation process

#### 2.2.1. Compiler overview

A compiler is a program that reads a program written in one language (the source language) and converts it into an equivalent program in another language (the target language).
A critical function of the compiler is to identify and report any errors found in the source program during the translation process, so that the developer can resolve the issues and retry again.
When the target program is a machine-language executable, the user can call it to process inputs and generate outputs.

Another type of language processor is an interpreter. Rather than producing a target program through translation, an interpreter executes the operations specified in the source program directly on the user-provided inputs.
Generally, a compiler-generated machine-language target program is significantly faster at mapping inputs to outputs compared to an interpreter. However, an interpreter often provides better error diagnostics than a compiler because it executes the source program statement by statement.

Creating an executable target program might require more than just a compiler. The source program could be split into modules stored in separate files, and gathering these into a single program might be the job of a separate program called a preprocessor.
The preprocessor can also expand macros, which are shorthand notations, into source language statements.

This modified source program is then sent to a compiler. The compiler's output might be an assembly-language program, as assembly language is easier to generate and debug. The assembly-language program is then processed by an assembler, producing relocatable machine code.

Large programs are often compiled in segments, necessitating the linking of relocatable machine code with other relocatable object files and library files to form the executable code that runs on the machine.
The linker resolves external memory addresses where code in one file refers to a location in another file. Finally, the loader assembles all executable object files into memory for execution.

#### 2.2.2. Structure of a compiler

Basically, compilation process can be divided into two main parts: analysis and synthesis.

During the analysis phase, the source program is broken down into its fundamental components, and a grammatical structure is applied to these components. This structure is then used to create an intermediate representation of the source program.
If the analysis phase finds that the source program is either syntactically incorrect or semantically flawed, it must provide informative messages to help the user make corrections.
Additionally, the analysis phase gathers information about the source program and stores it in a data structure known as a symbol table. This symbol table, along with the intermediate representation, is then passed to the synthesis phase.

In the synthesis phase, the target program is constructed using the intermediate representation and the information from the symbol table. The analysis phase is often referred to as the front end of the compiler, while the synthesis phase is known as the back end.
Upon closer inspection of the compilation process, we see that it functions as a series of phases, each transforming the representation of the source program. A typical breakdown of these phases is shown in Fig. 2.1. In practice, several phases might be combined, and the intermediate representations between these grouped phases might not be explicitly constructed.
The symbol table, which contains information about the entire source program, is utilized by all phases of the compiler.

The analysis part is often called the front end, and the synthesis part is called the back end. An interpreter, however, does not fit into this model, as it does not produce a target program. Instead, it directly executes the operations specified in the source program on the user-provided inputs.

![Compilation process phases](../images/2-1-compilation-process-phases.png)

Figure 2.1. Compilation process phases

##### 2.2.2.1. Symbol table

A key function of a compiler is to record the variable names used in the source program and gather information about various attributes of each name.
These attributes may include details about the allocated storage for a name, its type, its scope (where in the program its value can be used), and, in the case of procedure names, details such as the number and types of its arguments, the method of passing each argument (e.g., by value or by reference), and the return type.

The symbol table is a data structure that contains a record for each variable name, with fields for the name's attributes. This data structure should be designed to enable the compiler to quickly find the record for each name and efficiently store or retrieve data from that record.

##### 2.2.2.2. Lexical analysis

The first phase of a compiler is known as lexical analysis or scanning. During this phase, the lexical analyzer reads the stream of characters that make up the source program and groups these characters into meaningful sequences called lexemes. For each lexeme, the lexical analyzer generates a token in the form of

```txt
<token-name; attribute-value>
```

which it then passes to the next phase, syntax analysis. In this token, the first component, token-name, is an abstract symbol used in syntax analysis, while the second component, attribute-value, refers to an entry in the symbol table for this token. The information from the symbol table entry is essential for semantic analysis and code generation.

For example, a sequence of tokens after lexical analysis might look like this:

```txt
<id,1> <+=> <42> <*> <id,2>
```

In this representation, the tokens are `id` (identifier), `+=` (addition assignment operator), `42` (integer constant), `*` (multiplication operator), and `id` (identifier). The attribute values `1` and `2` refer to the symbol table entries for the identifiers.

##### 2.2.2.3. Syntax analysis

The second phase of a compiler is syntax analysis or parsing. During this phase, the parser takes the first components of the tokens generated by the lexical analyzer and uses them to create a tree-like intermediate representation that illustrates the grammatical structure of the token stream.
A common form of this representation is a syntax tree, where each interior node represents an operation, and the children of the node represent the arguments of that operation.

The following phases of the compiler utilize this grammatical structure to further analyze the source program and generate the target program.

##### 2.2.2.4. Semantic analysis

The semantic analyzer utilizes the syntax tree and the information in the symbol table to verify the source program's semantic consistency with the language definition. It also collects type information and stores it either in the syntax tree or the symbol table for later use during intermediate code generation.
A crucial aspect of semantic analysis is type checking, where the compiler ensures that each operator has compatible operands. For instance, many programming languages require an array index to be an integer; the compiler must report an error if a floating-point number is used as an array index.
The language specification may allow certain type conversions, known as coercions. For example, a binary arithmetic operator might be used with either a pair of integers or a pair of floating-point numbers. If the operator is applied to a floating-point number and an integer, the compiler can convert or coerce the integer to a floating-point number.

##### 2.2.2.5. Intermediate code generation

When translating a source program into target code, a compiler may create one or more intermediate representations, which can take various forms. Syntax trees are a common type of intermediate representation used during syntax and semantic analysis.

After completing the syntax and semantic analysis of the source program, many compilers generate a specific low-level or machine-like intermediate representation, which can be considered a program for an abstract machine. This intermediate representation should be easy to produce and straightforward to translate into the target machine.

One form of intermediate representation is known as three-address code, which comprises a sequence of assembly-like instructions with three operands per instruction. Each operand can function similarly to a register.

There are several noteworthy points about three-address instructions. First, each three-address assignment instruction has at most one operator on the right side, thereby determining the order of operations. Second, the compiler must generate a temporary name to store the value computed by a three-address instruction. Third, some three-address instructions have fewer than three operands.

Another form of intermediate representation is bytecode, which is then usually executed by an interpreter.
For example, Java language processor generates bytecode that is executed by the Java Virtual Machine (JVM). A benefit of using bytecode is that it allows the same compiled program to run on any machine that has an interpreter for the bytecode.

##### 2.2.2.6. Code optimization

The machine-independent code optimization phase aims to enhance the intermediate code to produce better target code. Typically, "better" means faster, but other goals, such as shorter code or code that uses less power, may also be important. For instance, a basic algorithm might generate intermediate code by using an instruction for each operator in the tree representation produced by the semantic analyzer.

Using a straightforward intermediate code generation algorithm followed by code optimization is an effective method for producing high-quality target code.

The extent of code optimization varies significantly among different compilers. In those that perform the most optimization, known as "optimizing compilers," a substantial amount of time is devoted to this phase. There are simple optimizations that can greatly improve the running time of the target program without significantly slowing down the compilation process.

##### 2.2.2.7. Code generation

The code generator receives an intermediate representation of the source program and translates it into the target language. If the target language is machine code, it involves selecting registers or memory locations for each variable used by the program.
The intermediate instructions are then converted into sequences of machine instructions that accomplish the same tasks. An essential part of code generation is the careful assignment of registers to store variables.

---

NOTES:

EVM is alike Java VM, and their compilation processes are similar too. [2.1, p.2-3, Example 1.1].

Chapter 6 describes principal intermediate representations used in compilers.

There is a great variation in the amount of code optimization different compilers perform. In those that do the most, the so-called optimizing compilers, "a significant amount of time is spent on this phase. There are simple optimizations that signifficantly improve the running time of the target programwithout slowing down compilation too much. The chapters from 8 on discuss
machine-independent and machine-dependent optimizations in detail. [2.1, p.10]

Data-flow analysis engines that facilitate the gathering of information about how values are transmitted from one part of a program to eachother part.
Data-flow analysis is a key part of code optimization. [2.1, p.12]

The science of code optimization [2.1, p.15, 1.4.2]

A high-level programming language defines a programming abstraction: the
programmer expresses an algorithm using the language, and the compiler must
translate that program to the target language. Generally, higher-level programming languages are easier to program in, but are less efficient, that is, the target
programs run more slowly. Programmers using a low-level language have more
control over a computation and can, in principle, produce more efficient code. [2.1, p.17]

A body of compiler optimizations, known as data-ow optimizations, has been developed to analyze
the ow of data through the program and removes redundancies across these
constructs. They are effective in generating code that resembles code written by a skilled programmer at a lower level. [2.1, p.18]
Read about data flow optimization?

TODO:
Should we describe the connection with the EVM here or move the entire "EVM" section to the "Compilation and bytecode" chapter?

## Chapter 3. Blockchain programming languages comparison

### 3.1. List of programming languages for blockchain development

#### 3.1.1. Solidity

#### 3.1.2. Yul

#### 3.1.3. Vyper

#### 3.1.4. eWASM

#### 3.1.5. Fe

#### 3.1.6. Flint

### 3.2. Criterias for comparison

[2.1: 1.5.5, 1.6]
